version : '3.9'

services :  # specify the different docker images to compose
  db : #name 
    image : postgres:15.2-alpine
    restart : always
    
    ports :
      - 5432:5432
    environment :
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    volumes : 
      - ./data:/var/lib/postgresql
 
  django :
    restart : always
    build : . #current directory
    depends_on:
      - db
      - redis
    volumes :
    # the host file system (file in the pc) is now plugged to the virtual container file system so data can be saved in it
      - .:/usr/src/app/backend # . : host directory relative to this file , /usr/src/app : container directory
    ports : #Activates the container to listen for specified port(s) from the world outside of the docker
          #(can be same host machine or a different machine) AND also accessible world inside docker.
      - 8000:8000 #port 8000 on container (externally) currosponds to 8000 on pc,  (eternally)
    # command : ["/wait-for-it.sh", "-t", "40", "db:5432", "--", "python", "manage.py","runserver","0.0.0.0:8000"]
    # command: sh -c "/wait-for-it.sh db:5432 -t 40 -- python manage.py runserver 0.0.0.0:8000 " # overwrite CMD in docker file


  react :
    restart: always
    depends_on:
      - django
    build : 
      context : ../AFLIX-Frontend
      target : development # use development step of the dockerfile
    
    volumes :
      - ../AFLIX-Frontend:/usr/src/app/frontend
    ports:
      - 3000:3000

  redis :
    image: redis:7.0.9-alpine
    ports: 
      - '6379:6379'

  celery :
    build : . #same build as django 
    command : celery -A backend worker -l INFO
    volumes : 
      - .:/usr/src/app/backend
    depends_on:
      - django
      
  celery_beat : 
    build : .
    command : celery -A backend beat
    volumes : 
      - .:/usr/src/app/backend
    depends_on:
      - celery
    
# to run docker compose , docker-compose up


# note : exposing a port means it is available to other containers only, to be accessed by outer machines(externally)
# this port has to be bound to a port in the host machine 
# docker compose automatically creates a bidge newtwork between containers to communicate, the alternative would be 
# to create a bridge network manually , and then connect the desired containers to communicate to this network using commands 
